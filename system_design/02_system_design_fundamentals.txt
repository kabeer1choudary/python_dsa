A) Networking & Communication - Networking is the foundation of system design
- Why networking matters
    * data exchange between components
    * enables scalbility, reliability & performance
    * communication - load balancing - security - efficiency

- How networking impacts Large scale systems
    * handles many users concurrently
    * efficient data exchange
    * reduces latency & improves resilience
    * essential for cloud & distributed systems

- Intro to IP Address
    * unique numerical labels assigned to devices in n/w
    * enables communication between different machines and services across internet
    * 2 versions - IPv4, IPv6
    * 2 categories - private, public
    * IPv4 - 32bit address - 4.3 billion
    * IPv6 - 128bit address - 340 undecillion
    * private ip - local n/w - cannot access internet directly
    * public ip - assigned by ISP - communicate over internet
    * need of private ips - IPV4 limitation - security - NAT (allow multiple devices to share single public ip)
    * role of ips - scalbility - security - load balancing - cloud networking - microservices & containers

- How DNS Works
    * translates human readable domain names into ip addresses
    * Types of DNS
        - Root Name Servers : top level servers handling .com, .org, .net etc.
        - TLD Name Servers : Top Level Domain NS, specific to domains
        - Authoritative NS : stores domain-specific records
        - Recursive Resolvers : handle queries on behalf od users, contains multiple DNS servers
    * DNS caching - reduces latency & load on DNS servers - caching happens in browser, OS, Recursive Resolvers - TTL (time-to-live) determines how long a cached record is valid
    * DNS process
        browser > OS > local DNS > root DNS > TLD NS > Authoritative NS > ip return to browser
    * DNS in large scale systems
        - ensures HA (using load balancing or anycast DNS)
        - failover strategies using primary & secondary servers
        - optimize CDNs performance
        - security risks (DNS poisoning, cache poisoning, DDoS attacks)

- Client - Server Model
    * client request services, servers provide them
    * foundation of web, db and app architecture
    * efficient resource management
    * Key components
        - Client : user facing app that sends requests
        - Server : system that process the requests and returns response
        - Network : medium that facilitates communication between client and server
    * Types of communication - request/response model (http), persistent connections, synchronous/asynchronous communication
    * Types of servers
        - stateful servers : maintain session info across requests - personalize - seamless user experiences
        - stateless servers : no memory of past session interactions, each request is independant, scalable - easy cache - loadbalanced
        
- Forward Proxy vs Reverse Proxy
    * proxy is an intermediary server between client and server - helps with security, caching, traffic control and anonymity
    * forward proxy - sits infront of the client - privacy, anonymity, content filtering, bypass geo-restrictions, caching
    * reverse proxy - sits between users and backend servers - load balancing, security & DDoS protection, SSL termination, caching & compression
    * forward proxy helps client interactions with internet securely
    * reverse proxy protects and optimizes backend servers

- Load Balancers
    * high availability - traffic distribution - prevents overload - handles failures gracefully - supports scalbility
    * Types of Load Balancers
        - Based on Layer : Layer 4 (Transport Layer - TCP/UDP), Layer 7 (Application Layer - HTTP/HTTPS)
        - Based on Deployment - Hardware LB, Software LB, Cloud based LB
    * LB strategies
        - Static Load Balancing : Round Robin, Least Connections, IP Hashing
        - Dynamic Load Balancing : Least Response time, Adaptive load balancing, Weighted load balancing

- API Gateways
    * APIs connect clients to backend services - exposing backend services lead to performance, security and management challanges
    * API Gateway is a centralized entry point for all API requests, handling authentication, routing, caching and security
    * API Gateway acts as reverse proxy between clients and backend services - receives API requests, process them and forward to correct services
    * Key functions of API Gateway - request transformation, authentication, rate limiting and response handling
    * Benefits of API Gateway - security, rate limiting, load balancing, caching, request trasformation, logging & monitoring
    * Security features of API Gateway - authentication & authorization, DDoS protection, Bot protection, TLS termination, rate limiting, throttling
    * Caching speeds up API responses by storing frequently accessed data
    * Types of Caching - in-memory caching, response caching, edge caching
    * API composition & aggregation - API Gateways combine multiple API calls into single request, useful for microservices architecture

- Content Delivery Networks (CDNs)
    * CDN - globally distributed network of servers that work together to deliver content efficiently
    * CDN reduces latency, enhances content availability, improves load handling, enables security
    * Components of CDN - Origin server, Edge server (PoP - point of presence), Request routing system (directs users to nearest PoP)
    * CDN workflow - user request > CDN routing system > cache hit (delivers the content)/cache miss (fetches content from origin)
    * Key features of CDN - caching & replication, load balancing & request routing, compression & optimization, security
        - cache expiration and TTL settings control the content freshness, caching invalidation strategies (manual purge, stale-while-revalidation)
        - load balancing across multiple PoPs, failover strategy (rerouting to another PoP, dynamic origin selection), request routing strategy (geo-based, latency-based, load-aware)
        - techniques of compression and minification (gzip & brotli compression, image optimization - webp/avif, minifying CSS/JS files to reduce file size)
        - DDoS mitigation (rate limiting, traffic filtering), SSL/TLS offloading
    * CDN use cases - static & dynamic content delivery, api acceleration & edge computing


B) Protocols
- TCP & UDP
    * Transmission Control Protocol - connection oriented, reliable, ordered, error-checked, ensures data reaches the destination correctly
    * User Datagram Protocol - conectionless, faster,no gurantee on deliivery, no retransmission of lost packets
    * Choose TCP if data integrity is critical - HTTP, HTTPS, FTP, SFTP, IMAP, SMTP, POP3, DB Communication
    * Choose UDP if speed is important - video streaming, online gaming, VoIP calls, DNS lookup

- HTTP - hyper text transfer protocol
    * defines rules for requesting and trasfering resources - works over TCP/IP (port 80 for http and port 443 for https)
    * text based protocol - stateless (each request is independent) - supports multiple methods (GET, POST, PUT, etc)
    * how HTTP works
        - client server model : client makes HTTP request, server processes the request and sends back a response
        - HTTP Request : Method (defined action - PUT, GET, etc), URL (resource being requested), Headers (metadata, user-agent, content type, etc.), Body (optional data sent in POST/PUT requests)
        - HTTP Response : Status code (indicate success or failure - 200, 302, etc), Headers (metadata about the response), Body (actual content returned)
    * stateless nature of HTTP
        - HTTP does not retain memory of previous requests
        - each request treated as independant transaction
        - hard to maintain user session and each request must carry all necessary information
        - to handle states we can use : cookies (small pieces of data stored in browser), sessions (server side storage of user state), tokens (JWT, OAuth - used for authentication and authorization)
    * HTTP Methods - GET, POST, PUT, DELETE, PATCH
    * HTTP status code - 1xx (informational), 2xx (success), 3xx (redirection), 4xx (client errors), 5xx (server errors)
    * HTTPS - secure version of HTTP, ensures data confidentiality, integrity, authentication, used for secure websites, works on port 443

- REST & RESTfulness - API Design Principles
    * REST - REpresentational State Transfer - architectural style for designing networked applications - uses HTTP methods and stateless communication
    * REST is scalable, simple, interoperable with different platforms and efficient with caching, stateless performance
    * REST Constraints - core Principles
        - client-server architecture
        - statelessness
        - cacheability
        - layered system
        - uniform interface
    * RESTful API design principles
        - resource based approach
        - proper HTTP methods usage
        - stateless interactions
        - consistency in URL structure
    * REST response - JSON (light weight, faster parsing, readable), XML (legacy system communication, data validation)
    * Best practices
        - use proper status code
        - versioning APIs
        - implement authentication
        - pagination
        - avoid using verbs in URLs

- Real-Time Communication Protocols
    * real time communication refers to contineous exchange of data with minimal latency
    * challanges of traditional request-response HTTP model due to latency and scalability issues
    * alternatives to improve real-time data exchange
        - polling
        - web sockets
        - server-sent events (SSE)
        - long polling
    * Web Sockets - persistent full duplex communication between client and server over a single TCP connection
        - persistent connection, low latency, reduces overhead compared to HTT polling, efficient for real-time applications
        - used in live chat apps, stock market price updates, multiplayer online games, collaborative tools, etc.
    * Long polling - simulating real time with HTTP
        - a technique where client sends request to server and waits until server has new data to respond with, then client immediately sends another request
        - used in periodic update notifications, IoT devices, etc.

- Modern API Protocols
    * limitations of REST APIs - over fetching & under fetching, high latency, not optimized for real time communication
    * need for modern solutions like gRPC & GraphQL to handle efficiency, flexibility and performance
    * gRPC - high performance binary protocol optimized for microservices & real-time communication - uses protocol buffers (ProtoBuf)
        - built on HTTP/2, allows multiplexed requests, compression, full duplex streaming, ProtoBuf for faster serialization, useful in multi-language ecosystems & low bandwidth apps
    * GraphQL - flexible query language that allows clients to fetch only the data they need - JSON based
        - instead of multiple REST endpoints, GraphQL has one endpoint where clients specify the data they need, GraphQL schema defines types & relationships between data
        - clients sends queries > graphql server resolves fields dynamically
        - used in front end optimization, reducing API requests, aggregate data from multiple services


C) Architectural Patterns
- Intro
    * software architecture - structure of a system including its components and relationships - importance of system design includes scalability, maintainability and performance
    
- Software architecture pattern & styles
    * software architecture is high-level structure of a software system, defining components, their relationships and the way they interactions
    * common architectural styles are
        - Monolithic : single unified system - simple to develop, deploy and manage in smaller apps - hard to scale, difficult to maintain as code base grows, high risk of failure - used in small apps, startups, simple CRUD based apps
        - Layered (N-tier) : system split into multiple layers - clear seperation of concerns, easier to scale and maintain compared to Monolithic - performance overhead due to layers, may result tight coupling between certain layers - used in enterprise apps, CRM systems, banking apps
        - Microservices : system built as collection of small independant services, each focuses on specific business capability - independant services, flexible tech stack, better fault tolerance, easy to scale, deploy and develop seperately - increases complexity in communication and co-ordination, needs robust devops/automation pipelines - used in large scale apps, e-commerce platforms, modern cloud based systems
        - Event-Driven : system where components communicate through events instead of direct calls, these are loose coupling - high decoupled architecture, excellent for handling asynchronous workflows, better scalability - debugging and tracing become more complex, difficult to ensure data consistency across services - used in real time systems, IoT apps, financial trading platforms
    * factors influencing architecture selection - business needs, scalability, performance, maintainability

D) Web Concepts in System Design